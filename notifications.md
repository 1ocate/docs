# Notifications

- [Introduction](#introduction)
    - [Driver Prerequisites](#driver-prerequisites)
- [Writing Notifications](#writing-notifications)
    - [Message Structure](#message-structure)
    - [Error Notifications](#error-notifications)
- [Sending Notifications](#sending-notifications)
    - [Determining Delivery Channels](#determining-delivery-channels)
    - [Via Mail](#via-mail)
    - [Via SMS](#via-sms)
    - [Via Slack](#via-slack)
    - [Via Database](#via-database)
    - [Queueing Notifications](#queueing-notifications)
- [Notification Events](#notification-events)
- [Custom Channels](#custom-channels)

## Introduction

In addition to support for [sending email](/docs/{{version}}/mail), Laravel also provides support for sending notifications across a variety of delivery channels, including mail, SMS (via [Nexmo](https://www.nexmo.com/)), [Slack](https://slack.com), and database tables. Notifications may also be stored in a database so that they may be displayed in your web interface.

Typically, notifications should be short, informational messages that notify your users of something that occurred in your application. For example, if you are writing a billing application, you might send an "Invoice Paid" notification to your users via the email and SMS channels.

<a name="driver-prerequisites"></a>
### Driver Prerequisites

#### SMS

The default SMS driver is powered by [Nexmo](https://www.nexmo.com/) and requires the Nexmo PHP client, which may be installed via the Composer package manager:

    composer require nexmo/client

#### Slack

The Slack notification driver requires the Guzzle HTTP library to make API requests to Slack. You can install Guzzle via the Composer package manager:

    composer require guzzlehttp/guzzle

<a name="writing-notifications"></a>
## Writing Notifications

In Laravel, each notification is represented by a single class, which is typically stored in the `app/Notifications` directory. Don't worry if you don't see this directory in your application, since it will be created for you when you run the `make:notification` Artisan command:

    php artisan make:notification InvoicePaid

This command will place a fresh notification class in your `app/Notifications` directory. Each notification class contains two important methods: `via` and `message`. The `via` method returns an array of channels that the notification should be delivered through. The `message` method builds the notification message.

<a name="message-structure"></a>
### Message Structure

Each notification message may consist of two parts: "lines" of texts and a "call to action". To better illustrate this, let's take a look at an example `message` method for an `InvoicePaid` notification:

    /**
     * Get the notification message.
     *
     * @return void
     */
    public function message()
    {
        $this->line('One of your invoices has been paid!')
             ->action('View Invoice', 'https://example.com/invoice/'.$this->invoice->id)
             ->line('Thank you for using our application!');
    }

In the example above, we register a line of text, a call to action, and then another line of text. Each notification channel will translate this notification structure into a format that makes sense for that channel. So, for example, when using the `mail` channel, the notification will be translated into a nice, responsive HTML email template. When using the `nexmo` channel, the notification will be formatted into a simple text message. For example, here is an example of an email generated by the `mail` channel:

<img src="https://laravel.com/assets/img/notification-example.png" width="551" height="596">

Note that we are using `$this->invoice->id` within our `message` method. You may pass any data your notification needs to generate its message into the notification constructor. This will typically be done when you send the notification.

<a name="error-notifications"></a>
### Error Notifications

Some notifications may be notifying the users of errors that have occurred within your application, such as an invoice payment failing. You may specify that a notification is an error by calling the `error` method when building your message. Some notification channels will use this information to customize the appearance of the notification. For example, when using the `mail` channel, the call to action button will be red instead of blue:

    /**
     * Get the notification message.
     *
     * @return void
     */
    public function message()
    {
        $this->error()
             ->subject('Notification Subject')
             ->line('...')
    }

<a name="sending-notifications"></a>
## Sending Notifications

Notifications may be sent in two ways: the `notify` method of the `Notifiable` trait or the `Notification` [facade](/docs/{{version}}/facades). First, let's examine the `Notifiable` trait. This trait is used by the `User` model by default and contains one method that may be used to send notifications: `notify`. The `notify` method accepts a notification instance:

    $user = App\User::find(1);

    $invoice = App\Invoice::find(1);

    $user->notify(new App\Notifications\InvoicePaid($invoice));

Alternatively, you may send notifications via the `Notification` facade. Using the `Notification` facade is primarily useful when you need to send a notification to multiple "notifiable" entities such as a collection of users:

    Notification::send($users, new InvoicePaid($invoice));

> {tip} Remember, you may use the `Illuminate\Notifications\Notifiable` trait on any of your models. You are not limited to only including it on your `User` model.

<a name="determining-delivery-channels"></a>
### Determining Delivery Channels

Each notification class contains a `via` method. This method determines which notification channels the notification will be delivered on. Out of the box, notifications may be sent on the: `mail`, `nexmo`, `slack`, and `database` channels. Note that the `via` method receives a `$notifiable` instance, which will be an instance of the class that the notification is being sent to. If needed, you may use this `$notifiable` instance to determine which channels the notification should be delivered on:

    /**
     * Get the notification channels.
     *
     * @param  mixed  $notifiable
     * @return array|string
     */
    public function via($notifiable)
    {
        if ($notifiable->prefers_sms) {
            return ['sms'];
        } else {
            return ['mail', 'database'];
        }
    }

<a name="via-mail"></a>
### Via Mail

When sending notifications via the `mail` channel, the notification system will automatically look for an `email` property on your notifiable entity. You may customize which email address is used to deliver the notification by defining a `routeNotificationForMail` method on the entity:

    <?php

    namespace App;

    use Illuminate\Notifications\Notifiable;
    use Illuminate\Foundation\Auth\User as Authenticatable;

    class User extends Authenticatable
    {
        use Notifiable;

        /**
         * Route notifications for the mail channel.
         *
         * @return string
         */
        public function routeNotificationForMail()
        {
            return $this->email_address;
        }
    }

#### Customizing The Subject

By default, the email's subject will be determined by "title casing" the class name of the notification. So, if your notification class is named `InvoicePaid`, the email's subject will be `Invoice Paid`. If you would like to specify an explicit subject for the message, you may call the `subject` method when building your message:

    /**
     * Get the notification message.
     *
     * @return void
     */
    public function message()
    {
        $this->subject('Notification Subject')
             ->line('...')
    }

<a name="via-sms"></a>
### Via SMS

#### Configuration

Sending SMS notifications in Laravel is powered by [Nexmo](https://www.nexmo.com/). Before sending notifications via Nexmo, you will need to install the `nexmo/client` Composer package and add a few configuration options to your `config/services.php` configuration file. You may copy the example configuration below to get started:

    'nexmo' => [
        'key' => env('NEXMO_KEY'),
        'secret' => env('NEXMO_SECRET'),
        'sms_from' => '15556666666',
    ],

The `sms_from` configuration option is the phone number that your SMS messages will be sent from. You may generate a phone number for your application in the Nexmo control panel.

#### Routing Nexmo SMS Notifications

When sending notifications via the `nexmo` channel, the notification system will automatically look for a `phone_number` attribute on the notifiable entity. If you would like to customize the phone number that the notification is delivered to, define a `routeNotificationForNexmo` method on the entity:

    <?php

    namespace App;

    use Illuminate\Notifications\Notifiable;
    use Illuminate\Foundation\Auth\User as Authenticatable;

    class User extends Authenticatable
    {
        use Notifiable;

        /**
         * Route notifications for the Nexmo channel.
         *
         * @return string
         */
        public function routeNotificationForNexmo()
        {
            return $this->phone;
        }
    }

<a name="via-slack"></a>
### Via Slack

In order to send notifications via Slack, you must first install the Guzzle HTTP library via the Composer package manager:

    composer require guzzlehttp/guzzle

Next, you need to define a `routeNotificationForSlack` method on your notifiable entity. This method should return the webhook URL that the notification should be delivered to. Webhook URLs may be generated by adding an "Incoming Webhook" service to your Slack team:

    <?php

    namespace App;

    use Illuminate\Notifications\Notifiable;
    use Illuminate\Foundation\Auth\User as Authenticatable;

    class User extends Authenticatable
    {
        use Notifiable;

        /**
         * Route notifications for the Slack channel.
         *
         * @return string
         */
        public function routeNotificationForSlack()
        {
            return $this->slack_webhook_url;
        }
    }

<a name="via-database"></a>
### Via Database

#### Creating The Database Table

The database notification channel stores the notification information in a database table. You can then query the table to display the notifications in your application's user interface. But, before getting started, you will need to create a database table to hold your notifications. You may use the schema definition below to create a table with the proper fields:

    Schema::create('notifications', function (Blueprint $table) {
        $table->increments('id');
        $table->string('notifiable_type');
        $table->integer('notifiable_id');
        $table->string('level', 25);
        $table->text('intro');
        $table->text('outro');
        $table->string('action_text')->nullable();
        $table->string('action_url')->nullable();
        $table->boolean('read');
        $table->timestamps();

        $table->index(['notifiable_type', 'notifiable_id']);
    });

#### Accessing The Notifications

The `Illuminate\Notifications\Notifiable` trait includes a `notifications` Eloquent relationship method which returns the notifications for the notifiable entity. So, in order to retrieve the notifications, you may access this method like any other Eloquent relationship. By default, notifications will be sorted by the `created_at` timestamp:

    $user = App\User::find(1);

    foreach ($user->notifications as $notification) {
        echo $notification->action_text;
    }

If you would like to only retrieve the "unread" notifications, you may use the `unreadNotifications` relationship. Again, these notifications will be sorted by the `created_at` timestamp:

    $user = App\User::find(1);

    foreach ($user->unreadNotifications as $notification) {
        echo $notification->action_text;
    }

#### Marking Notifications As Read

Typically, you will want to mark a notification as "read" once a user views it in your application's user interface. The `Illuminate\Notifications\Notifiable` trait provides a `markAsRead` method which will update the `read` column on the notification's database record:

    $user = App\User::find(1);

    foreach ($user->notifications as $notification) {
        $notification->markAsRead();
    }

You may also use a mass-update query to mark all of the notifications as read:

    $user = App\User::find(1);

    $user->notifications()->update(['read' => true]);

Of course, you may `delete` the notifications to remove them from the table:

    $user->notifications()->delete();

<a name="queueing-notifications"></a>
### Queueing Notifications

> {note} Before queueing notifications, be sure to configure your queue and [start a queue worker](/docs/{{version}}/queues).

Sending notifications can be time consuming, especially if the channel requires an external API call to deliver the notification. To speed up your application's response time, you may specify that the notification should be queued by adding the `ShouldQueue` interface and `Queueable` trait to your notification class. The interface and trait are already imported into the current namespace for all notifications generated using `make:notification`, so you may immediately add them to your notification class:

    <?php

    namespace App\Notifications;

    use Illuminate\Bus\Queueable;
    use Illuminate\Notifications\Notification;
    use Illuminate\Contracts\Queue\ShouldQueue;

    class InvoicePaid extends Notification implements ShouldQueue
    {
        use Queueable;

        // ...
    }

Once the `ShouldQueue` interface has been added to your notification, you may send the notification like normal. Laravel will detect the `ShouldQueue` interface on the class and automatically queue the delivery of the notification:

    $user->notify(new InvoicePaid($invoice));

If you would like to delay the deliver of the notification, you may chain the `delay` method onto your notification instantiation:

    $when = Carbon::now()->addMinutes(10);

    $user->notify((new InvoicePaid($invoice))->delay($when));

<a name="notification-events"></a>
## Notification Events

When a notification is sent, the `Illuminate\Notifications\Events\NotificationSent` event is fired by the notification system. This event contains the "notifiable" entity as well as the notification instance itself. Of course, you may register listeners for this event in your `EventServiceProvider`:

    /**
     * The event listener mappings for the application.
     *
     * @var array
     */
    protected $listen = [
        'Illuminate\Notifications\Events\NotificationSent' => [
            'App\Listeners\LogNotification',
        ],
    ];

> {tip} After registering listeners in your `EventServiceProvider`, use the `event:generate` Artisan command to quickly generate the listener classes.

Within an event listener, you may access the `notifiable` and `notification` properties on the event to learn more about the notification recipient or the notification itself:

    /**
     * Handle the event.
     *
     * @param  NotificationSent  $event
     * @return void
     */
    public function handle(NotificationSent $event)
    {
        // $event->notifiable
        // $event->notification
    }

<a name="custom-channels"></a>
## Custom Channels

Laravel ships with a handful of notification channels; however, you may want to write your own drivers to deliver notifications via other channels. Thankfully, Laravel makes it simple to define your own channels. To get started, simply define a class that contains a `send` method. The method should receive two arguments: a collection of `$notifiables` and a `$notification` instance:

    <?php

    use App\Channels;

    use Illuminate\Support\Collection;
    use Illuminate\Notifications\Notification;

    class VoiceChannel
    {
        /**
         * Send the given notification.
         *
         * @param  \Illuminate\Support\Collection  $notifiables
         * @param  \Illuminate\Notifications\Notification  $notification
         * @return void
         */
        public function send(Collection $notifiables, Notification $notification)
        {
            foreach ($notifiables as $notifiable) {
                // Send notification to the $notifiable instance...
            }
        }
    }

Once your notification channel class has been defined, you may simply return the class name from the `via` method of any of your notifications:

    <?php

    namespace App\Notifications;

    use Illuminate\Bus\Queueable;
    use App\Channels\VoiceChannel;
    use Illuminate\Notifications\Notification;
    use Illuminate\Contracts\Queue\ShouldQueue;

    class InvoicePaid extends Notification
    {
        use Queueable;

        /**
         * Get the notification channels.
         *
         * @param  mixed  $notifiable
         * @return array|string
         */
        public function via($notifiable)
        {
            return [VoiceChannel::class];
        }

        /**
         * Get the notification message.
         *
         * @return void
         */
        public function message()
        {
            // ...
        }
    }
